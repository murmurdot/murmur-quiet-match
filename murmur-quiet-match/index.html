<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>murmur — quiet match</title>
  <meta name="description" content="A calm, minimal match-3 with café vibes." />
  <style>
    :root{
      --bg:#fafafa;
      --ink:#1a1a1a;
      --soft:#e9e9e9;
      --line:#d8d8d8;
      --accent:#7a8a87; /* muted green-grey */
      --good:#3aa17e;
      --warn:#bf5a5a;
      --tile-size:72px; /* responsive below */
      --radius:16px;
      --shadow:0 8px 30px rgba(0,0,0,.08);
    }
    html,body{height:100%}
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--ink);
      background:var(--bg);
    }
    header{
      display:flex;align-items:center;justify-content:center;gap:16px;
      padding:18px 12px 8px;
    }
    header .brand{font-weight:600;letter-spacing:.08em;text-transform:lowercase}
    header img{height:64px;width:auto}

    .wrap{max-width:1100px;margin:0 auto;padding:12px}

    .card{background:#fff;border:1px solid var(--line);border-radius:24px;box-shadow:var(--shadow)}

    .topbar{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:12px 16px;border-bottom:1px solid var(--line)}
    .topbar .left, .topbar .right{display:flex;align-items:center;gap:8px}

    .btn{appearance:none;border:1px solid var(--line);background:#fff;border-radius:999px;padding:10px 14px;font-size:14px;cursor:pointer;transition:transform .06s ease, background .2s, border-color .2s}
    .btn:hover{transform:translateY(-1px)}
    .btn[aria-pressed="true"]{background:#111;color:#fff;border-color:#111}

    .seg{display:flex;background:var(--soft);border-radius:999px;padding:4px}
    .seg button{border:none;background:transparent;border-radius:999px;padding:8px 12px;cursor:pointer}
    .seg button[aria-pressed="true"]{background:#fff;box-shadow:var(--shadow)}

    /* Start screen */
    #start{
      position:relative;overflow:hidden;
      display:grid;grid-template-columns:1fr;place-items:center;min-height:68vh
    }
    #start .inner{padding:32px;display:flex;flex-direction:column;gap:18px;align-items:center;text-align:center}
    #start .title{font-size:28px;font-weight:600;letter-spacing:.06em}
    #start .subtitle{opacity:.7}
    #start .cat{position:absolute;right:8px;bottom:0;opacity:.9;max-width:min(40vw,320px);}
    #start .panel{display:flex;gap:12px;align-items:center}

    /* Game area */
    #game{display:none}
    #hud{display:flex;gap:10px;align-items:center}
    #hud .pill{border:1px solid var(--line);padding:10px 14px;border-radius:999px;background:#fff;min-width:84px;text-align:center}
    #board-wrap{padding:18px;display:flex;justify-content:center}

    #board{
      display:grid;gap:10px;padding:12px;background:linear-gradient(180deg,#ffffff,#f6f6f6);border:1px solid var(--line);border-radius:24px;box-shadow:var(--shadow)
    }
    .cell{
      width:var(--tile-size);height:var(--tile-size);border-radius:18px;display:grid;place-items:center;background:#fff;border:1px solid var(--line);position:relative;overflow:hidden;transition:transform .12s ease
    }
    .cell img{width:90%;height:90%;object-fit:contain;pointer-events:none;user-select:none;transition:transform .12s ease}
    .cell.selected{outline:3px solid var(--accent)}
    .cell.matching{animation:pop .3s ease}
    @keyframes pop{0%{transform:scale(.95);opacity:.6}100%{transform:scale(1);opacity:1}}

    .footer{padding:12px 16px;border-top:1px solid var(--line);display:flex;justify-content:space-between;align-items:center}
    .muted{opacity:.6}

    .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#111;color:#fff;padding:10px 14px;border-radius:999px;opacity:0;transition:opacity .2s, transform .2s;pointer-events:none}
    .toast.show{opacity:1;transform:translateX(-50%) translateY(-3px)}

    /* Responsive */
    @media (max-width:980px){
      :root{--tile-size:64px}
    }
    @media (max-width:720px){
      :root{--tile-size:56px}
      #start .cat{max-width:min(44vw,280px)}
    }
    @media (max-width:560px){
      :root{--tile-size:52px}
    }
  </style>
</head>
<body>
  <header class="wrap">
    <img src="assets/images/banner.png" alt="murmur banner" width="400" height="64" />
    <div class="brand">murmur — quiet match</div>
  </header>

  <main class="wrap card" id="start">
    <img class="cat" src="assets/images/welcome_cat.png" alt="cat" />
    <div class="inner">
      <div class="title">quiet match</div>
      <div class="subtitle">choose your mood, then start.</div>

      <div class="panel" role="group" aria-label="Mode">
        <div class="seg" id="modeSeg">
          <button type="button" data-mode="calm" aria-pressed="true">Calm</button>
          <button type="button" data-mode="challenge" aria-pressed="false">Challenge</button>
        </div>
      </div>

      <div class="panel" role="group" aria-label="Audio">
        <button class="btn" id="musicToggle" aria-pressed="false" title="Music is Off by default">Music: Off</button>
        <button class="btn" id="sfxToggle" aria-pressed="true">SFX: On</button>
      </div>

      <div class="panel">
        <button class="btn" id="startBtn"><strong>Start</strong></button>
      </div>

      <div class="muted" style="font-size:12px">Tip: Music starts only after you click. SFX is on.</div>
    </div>
  </main>

  <section class="wrap card" id="game" aria-live="polite">
    <div class="topbar">
      <div class="left" id="hud">
        <div class="pill">Score: <span id="score">0</span></div>
        <div class="pill" id="movesWrap" hidden>Moves: <span id="moves">0</span></div>
        <div class="pill" id="timeWrap" hidden>Time: <span id="time">60</span>s</div>
      </div>
      <div class="right">
        <button class="btn" id="musicBtn" aria-pressed="false">Music: Off</button>
        <button class="btn" id="sfxBtn" aria-pressed="true">SFX: On</button>
        <button class="btn" id="restartBtn">Restart</button>
      </div>
    </div>

    <div id="board-wrap">
      <div id="board" role="grid" aria-label="Match board"></div>
    </div>

    <div class="footer">
      <div class="muted">murmur · a calm match-3 with café sweets</div>
      <div class="muted" id="status"></div>
    </div>
  </section>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
    // ------- Config -------
    const TILE_IMAGES = [
      'assets/images/lemon_soda_tile.png',
      'assets/images/cafelatte_tile.png',
      'assets/images/strawberry_tart_tile.png',
      'assets/images/caramelpudding_tile.png',
      'assets/images/violet_soda_tile.png',
      'assets/images/vanilla_macaron_tile.png',
    ];

    const SFX = {
      choice: new Audio('assets/audio/choice.mp3'),
      match:  new Audio('assets/audio/match.mp3')
    };
    // Low-latency-ish
    SFX.choice.preload = 'auto';
    SFX.match.preload  = 'auto';

    const BGMS = [
      'assets/audio/match_game_bgm_1.mp3',
      'assets/audio/match_game_bgm_2.mp3',
      'assets/audio/match_game_bgm_3.mp3',
      'assets/audio/match_game_bgm_4.mp3',
      'assets/audio/match_game_bgm_5.mp3',
    ];

    let musicEnabled = false; // initial off
    let sfxEnabled   = true;  // initial on

    let music = new Audio();
    music.loop = false; // we will chain randomly
    music.volume = 0.7;
    let currentBgmIndex = -1;

    function pickNextBgm(){
      let idx;
      do{ idx = Math.floor(Math.random() * BGMS.length); } while(idx === currentBgmIndex && BGMS.length>1);
      currentBgmIndex = idx;
      music.src = BGMS[idx];
    }
    music.addEventListener('ended', ()=>{
      if(!musicEnabled) return;
      pickNextBgm(); music.play().catch(()=>{});
    });

    function startMusic(){
      if(!musicEnabled){ musicEnabled = true; pickNextBgm(); music.play().catch(()=>{}); }
      updateAudioButtons();
    }
    function stopMusic(){ musicEnabled=false; music.pause(); updateAudioButtons(); }

    function playSfx(name){
      if(!sfxEnabled) return;
      try{
        const a = SFX[name]; a.currentTime = 0; a.play();
      }catch(e){}
    }

    // ------- State -------
    const rows = 8, cols = 8; // balanced footprint
    const boardEl = document.getElementById('board');
    const scoreEl = document.getElementById('score');
    const statusEl = document.getElementById('status');
    const toastEl = document.getElementById('toast');

    let grid = []; // 2D of tile indices 0..5; -1 for empty
    let score = 0;
    let selected = null; // {r,c}
    let busy = false;

    // Modes
    let mode = 'calm'; // calm | challenge
    let movesLeft = 0; let timeLeft = 60; let timerId = null;

    function setMode(next){
      mode = next;
      document.querySelectorAll('#modeSeg button').forEach(btn=>btn.setAttribute('aria-pressed', String(btn.dataset.mode===mode)));
      document.getElementById('movesWrap').hidden = (mode!=='challenge');
      document.getElementById('timeWrap').hidden  = (mode!=='challenge');
      document.getElementById('status').textContent = (mode==='challenge')? 'Challenge: 60s timer · make as many matches as you can' : 'Calm: endless play';
    }

    // ------- UI wiring -------
    const musicToggle = document.getElementById('musicToggle');
    const sfxToggle = document.getElementById('sfxToggle');
    const startBtn = document.getElementById('startBtn');
    const musicBtn = document.getElementById('musicBtn');
    const sfxBtn   = document.getElementById('sfxBtn');
    const restartBtn = document.getElementById('restartBtn');

    document.getElementById('modeSeg').addEventListener('click', (e)=>{
      const b = e.target.closest('button'); if(!b) return; setMode(b.dataset.mode);
    });

    function updateAudioButtons(){
      const set = (btn, on, label)=>{ btn.setAttribute('aria-pressed', String(on)); btn.textContent = label + (on?': On':': Off'); }
      set(musicToggle, musicEnabled, 'Music');
      set(sfxToggle,   sfxEnabled,   'SFX');
      set(musicBtn,    musicEnabled, 'Music');
      set(sfxBtn,      sfxEnabled,   'SFX');
    }

    musicToggle.addEventListener('click', ()=>{ musicEnabled? stopMusic(): startMusic(); });
    sfxToggle.addEventListener('click', ()=>{ sfxEnabled = !sfxEnabled; updateAudioButtons(); showToast('SFX '+(sfxEnabled?'On':'Off')); });

    musicBtn.addEventListener('click', ()=>{ musicEnabled? stopMusic(): startMusic(); });
    sfxBtn.addEventListener('click', ()=>{ sfxEnabled = !sfxEnabled; updateAudioButtons(); showToast('SFX '+(sfxEnabled?'On':'Off')); });

    startBtn.addEventListener('click', ()=>{
      // First user gesture -> allow audio
      if (musicEnabled) { startMusic(); }
      // Transition to game
      document.getElementById('start').style.display='none';
      document.getElementById('game').style.display='block';
      initGame();
    });

    restartBtn.addEventListener('click', ()=>{ initGame(true); });

    // ------- Board helpers -------
    function coordKey(r,c){ return r+','+c; }

    function createBoardDom(){
      boardEl.style.gridTemplateColumns = `repeat(${cols}, var(--tile-size))`;
      boardEl.innerHTML = '';
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const cell = document.createElement('div');
          cell.className='cell';
          cell.setAttribute('role','gridcell');
          cell.dataset.r=r; cell.dataset.c=c;
          cell.addEventListener('click', onCellClick);
          const img = document.createElement('img');
          img.alt = '';
          cell.appendChild(img);
          boardEl.appendChild(cell);
        }
      }
    }

    function setCellImage(r,c){
      const idx = grid[r][c];
      const cell = getCell(r,c);
      const img = cell.querySelector('img');
      if(idx>=0){ img.src = TILE_IMAGES[idx]; cell.style.visibility='visible'; }
      else{ img.removeAttribute('src'); cell.style.visibility='hidden'; }
    }

    function getCell(r,c){ return boardEl.children[r*cols + c]; }

    function onCellClick(e){
      if(busy) return;
      const cell = e.currentTarget; const r = +cell.dataset.r, c = +cell.dataset.c;
      if(selected && selected.r===r && selected.c===c){ // deselect
        getCell(r,c).classList.remove('selected'); selected=null; return;
      }
      if(!selected){
        selected={r,c}; cell.classList.add('selected'); playSfx('choice');
      }else{
        const {r:sr,c:sc}=selected;
        if(Math.abs(sr-r)+Math.abs(sc-c)!==1){
          // new selection
          getCell(sr,sc).classList.remove('selected');
          selected={r,c}; cell.classList.add('selected'); playSfx('choice');
        }else{
          // attempt swap
          swapAndResolve(sr,sc,r,c);
        }
      }
    }

    function swapValues(r1,c1,r2,c2){
      const t=grid[r1][c1]; grid[r1][c1]=grid[r2][c2]; grid[r2][c2]=t;
      setCellImage(r1,c1); setCellImage(r2,c2);
    }

    function findMatches(){
      const matched = new Set();
      // rows
      for(let r=0;r<rows;r++){
        let run=1;
        for(let c=1;c<cols;c++){
          if(grid[r][c]!==-1 && grid[r][c]===grid[r][c-1]) run++; else { if(run>=3){ for(let k=0;k<run;k++) matched.add(coordKey(r,c-1-k)); } run=1; }
        }
        if(run>=3){ for(let k=0;k<run;k++) matched.add(coordKey(r,cols-1-k)); }
      }
      // cols
      for(let c=0;c<cols;c++){
        let run=1;
        for(let r=1;r<rows;r++){
          if(grid[r][c]!==-1 && grid[r][c]===grid[r-1][c]) run++; else { if(run>=3){ for(let k=0;k<run;k++) matched.add(coordKey(r-1-k,c)); } run=1; }
        }
        if(run>=3){ for(let k=0;k<run;k++) matched.add(coordKey(rows-1-k,c)); }
      }
      return matched;
    }

    function hasAnyMoves(){
      // Check if any adjacent swap would make a match
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const here = grid[r][c];
          const trySwap=(r2,c2)=>{
            if(r2<0||r2>=rows||c2<0||c2>=cols) return false;
            const t=grid[r2][c2]; if(t===here) return false; // skip same to reduce work
            grid[r][c]=t; grid[r2][c2]=here;
            const ok = findMatches().size>0;
            grid[r][c]=here; grid[r2][c2]=t; // revert
            return ok;
          }
          if(trySwap(r, c+1) || trySwap(r+1, c)) return true;
        }
      }
      return false;
    }

    async function swapAndResolve(r1,c1,r2,c2){
      busy = true; playSfx('choice');
      getCell(r1,c1).classList.remove('selected');
      selected=null;
      swapValues(r1,c1,r2,c2);
      await delay(90);
      let m = findMatches();
      if(m.size===0){ // swap back
        swapValues(r1,c1,r2,c2);
        busy = false; return;
      }
      await resolveMatches(m);
      if(mode==='challenge'){ movesLeft--; updateHud(); }
      busy = false;
      // If no moves, reshuffle
      if(!hasAnyMoves()){
        reshuffle();
        showToast('No moves — reshuffling');
      }
    }

    async function resolveMatches(matchedSet){
      // Visual cue
      matchedSet.forEach(key=>{
        const [r,c]=key.split(',').map(Number);
        getCell(r,c).classList.add('matching');
      });
      await delay(120);
      // Clear
      matchedSet.forEach(key=>{
        const [r,c]=key.split(',').map(Number);
        grid[r][c] = -1; setCellImage(r,c);
      });
      playSfx('match');
      // Score
      const gained = 10 * matchedSet.size; score += gained; scoreEl.textContent=score;
      // Gravity
      for(let c=0;c<cols;c++){
        let wr = rows-1;
        for(let r=rows-1;r>=0;r--){
          if(grid[r][c]!==-1){ grid[wr][c]=grid[r][c]; wr--; }
        }
        for(let r=wr;r>=0;r--){ grid[r][c] = -1; }
      }
      renderAll();
      await delay(80);
      // Refill
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(grid[r][c]===-1){ grid[r][c] = randTileFor(r,c,true); setCellImage(r,c); }
        }
      }
      await delay(80);
      // Cascade
      const more = findMatches();
      if(more.size>0) await resolveMatches(more);
    }

    function renderAll(){ for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) setCellImage(r,c); }

    function randInt(n){ return Math.floor(Math.random()*n); }

    function randTileFor(r,c,ignorePrev=false){
      // Pick a tile that does not create immediate 3+ at (r,c)
      let choices=[0,1,2,3,4,5];
      const left1 = (c>=1)? grid[r][c-1] : -99;
      const left2 = (c>=2)? grid[r][c-2] : -98;
      const up1   = (r>=1)? grid[r-1][c] : -97;
      const up2   = (r>=2)? grid[r-2][c] : -96;
      choices = choices.filter(x=> !(x===left1 && x===left2) && !(x===up1 && x===up2));
      if(!choices.length) choices=[0,1,2,3,4,5];
      return choices[randInt(choices.length)];
    }

    function generateInitialGrid(){
      grid = Array.from({length:rows}, ()=>Array(cols).fill(0));
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          grid[r][c] = randTileFor(r,c);
        }
      }
      // Ensure at least one move exists; if not, regenerate
      let safecount=0;
      while(!hasAnyMoves()){
        // Lightweight reshuffle
        reshuffle();
        if(++safecount>20) break;
      }
    }

    function reshuffle(){
      // Keep distribution; shuffle until no starting matches and has moves
      const flat = grid.flat();
      let tries=0;
      do{
        shuffleArray(flat);
        // reapply
        for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) grid[r][c]=flat[r*cols+c];
        tries++;
        if(tries>20){ // fallback: regenerate entirely
          generateInitialGrid(); return;
        }
      } while(findMatches().size>0 || !hasAnyMoves());
      renderAll();
    }

    function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

    function delay(ms){ return new Promise(res=>setTimeout(res, ms)); }

    // ------- Game lifecycle -------
    function initGame(fromRestart=false){
      // Reset state
      score = 0; scoreEl.textContent='0'; selected=null; busy=false;
      createBoardDom();
      generateInitialGrid();
      renderAll();
      updateAudioButtons();

      // Mode specifics
      if(mode==='challenge'){
        movesLeft = 0; // unlimited moves; timer-based
        timeLeft = 60;
        updateHud();
        if(timerId) clearInterval(timerId);
        timerId = setInterval(()=>{
          timeLeft--; updateHud();
          if(timeLeft<=0){ clearInterval(timerId); timerId=null; endChallenge(); }
        },1000);
      }else{
        if(timerId){ clearInterval(timerId); timerId=null; }
        document.getElementById('movesWrap').hidden = true;
        document.getElementById('timeWrap').hidden = true;
      }

      if(fromRestart) showToast('Restarted');
    }

    function updateHud(){
      document.getElementById('moves').textContent = movesLeft;
      document.getElementById('time').textContent = timeLeft;
    }

    function endChallenge(){
      busy=true;
      showToast(`Time! Score: ${score}`);
      statusEl.textContent = `Challenge finished — Score: ${score}. Tap Restart to try again.`;
    }

    function showToast(text){
      toastEl.textContent = text; toastEl.classList.add('show');
      clearTimeout(showToast._t); showToast._t = setTimeout(()=>toastEl.classList.remove('show'), 1600);
    }

    // ------- Preload assets and basic error logging -------
    (function preload(){
      // images
      TILE_IMAGES.concat(['assets/images/banner.png','assets/images/welcome_cat.png']).forEach(src=>{
        const im = new Image(); im.src = src; im.onerror = ()=>console.warn('Image missing?', src);
      });
      // audio: we set src via constructors already; ping once to warm cache
      Object.values(SFX).forEach(a=>{ a.load(); a.onerror = ()=>console.warn('SFX missing?', a.src); });
      // music sequence
      pickNextBgm(); // set first src (won't play until user enables)
      music.onerror = ()=>console.warn('BGM missing?', music.src);
    })();

    // Initialize toggles to reflect initial state
    setMode('calm');
    updateAudioButtons();
  </script>
</body>
</html>
