<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>murmur. â€” quiet match (prototype)</title>
<style>
  :root{
    --bg:#f5f5f3; --card:#ffffff; --ink:#1f2937; --muted:#6b7280; --shadow: 0 10px 30px rgba(0,0,0,.08);
    --cell: clamp(48px, 14vw, 78px);
    --accent:#111827;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family: ui-sans-serif, system-ui, -apple-system, "Helvetica Neue", Roboto, "Segoe UI", Arial;}
  .wrap{min-height:100%;display:grid;place-items:center;padding:20px}
  .app{width:min(100%, 980px)}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  .brand{display:flex;gap:12px;align-items:center;justify-content:center;width:100%}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:center}
  button{appearance:none;border:none;background:var(--card);box-shadow:var(--shadow);padding:10px 14px;border-radius:14px;color:var(--ink);cursor:pointer;transition:transform .06s ease, opacity .2s ease}
  button:hover{transform:translateY(-1px)}
  input[type="range"]{accent-color:#94a3b8}
  .card{background:var(--card);box-shadow:var(--shadow);border-radius:22px;padding:16px}
  .hud{display:flex;justify-content:space-between;align-items:center;margin:8px auto 14px; width:min(92vw,720px); gap:10px; flex-wrap:wrap}
  .pill{background:var(--card);box-shadow:var(--shadow);border-radius:999px;padding:8px 12px;color:var(--muted)}

  .board-wrap{position:relative; width:min(92vw, 720px); margin:0 auto}
  .grid{--size:6; display:grid; grid-template-columns:repeat(var(--size), var(--cell)); gap:8px; width:calc(var(--cell)*var(--size) + 16px); max-width:92vw; margin:0 auto}
  .tile{position:relative; width:var(--cell); height:var(--cell); border-radius:16px; display:grid; place-items:center; user-select:none; cursor:pointer; transition:transform .12s ease, filter .2s ease; border:1px solid rgba(0,0,0,.03); overflow:hidden}
  .tile img{width:80%; height:80%; object-fit:contain; pointer-events:none}
  .tile:hover{filter:brightness(1.03)}
  .tile.selected{outline:3px solid rgba(31,41,55,.25); transform:scale(1.04)}
  .tile.clearing{animation:pop .38s ease forwards}
  @keyframes pop{40%{transform:scale(1.08)}70%{transform:scale(1.14)}100%{transform:scale(.2); opacity:0}}

  .help{margin:16px auto 6px; width:min(92vw,720px); color:#4b5563; font-size:.9rem}
  .footer{margin:12px auto 0; width:min(92vw,720px); color:#6b7280; font-size:.85rem; text-align:center}

  /* Centered combo toast over the board */
  #toast{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%) scale(.9); background:rgba(255,255,255,.95); box-shadow:0 18px 40px rgba(0,0,0,.18); border-radius:999px; padding:10px 14px; font-weight:900; font-size:1.2rem; letter-spacing:.02em; opacity:0; pointer-events:none; transition:opacity .2s ease, transform .35s cubic-bezier(.2,.8,.2,1); z-index:5}
  #toast.show{opacity:1; transform:translate(-50%,-50%) scale(1)}
  #toast .jump{margin-left:8px; font-weight:800; font-size:.9rem; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#374151;}

  /* Overlay (mode select / stage select / dialogs) */
  .overlay{position:fixed; inset:0; background:rgba(17,24,39,.46); display:none; align-items:center; justify-content:center; z-index:50}
  .overlay.show{display:flex}
  .sheet{position:relative; background:#fff; border-radius:20px; box-shadow:0 30px 80px rgba(0,0,0,.2); width:min(92vw,760px); padding:18px; text-align:center}
  .sheet h2{margin:6px 0 10px; font-size:1.2rem; text-align:center}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:center}
  .btn{background:var(--accent); color:#fff; padding:10px 14px; border-radius:12px}
  .btn.secondary{background:#e5e7eb; color:#111}
  .stage-grid{display:grid; grid-template-columns:repeat(auto-fill, minmax(56px,1fr)); gap:8px; max-height:min(60vh,520px); overflow:auto; padding:8px}
  .stage{background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:10px 0; text-align:center; cursor:pointer}
  .stage.lock{opacity:.4; cursor:not-allowed}
  .stage.clear{border-color:#a7f3d0; background:#ecfdf5}
  .meta{color:#6b7280; font-size:.9rem; text-align:left}
  .close-btn{position:absolute; right:10px; top:10px; width:28px; height:28px; border-radius:999px; background:#ffffffcc; border:1px solid #e5e7eb; box-shadow:0 2px 8px rgba(0,0,0,.08); display:grid; place-items:center; cursor:pointer}
  .close-btn:hover{background:#fff}
  .welcome-cat{position:absolute; right:10px; bottom:8px; width:min(38vw, 320px); height:auto; opacity:.98; pointer-events:none}
</style>
</head>
<body>
<div class="wrap">
  <div class="app">
    <header>
      <div class="brand">
        <img src="images/banner.png" alt="murmur. quiet match â€” prototype" style="width:400px; height:auto;" />
      </div>
      <div class="controls">
        <button id="resetBtn" title="New board">New board</button>
        <button id="hintBtn" title="Show a possible move">Hint</button>
        <button id="modeBtn" title="Toggle play mode">Mode: Calm</button>
        <button id="paceBtn" title="Toggle pace">Pace: Normal</button>
        <button id="musicBtn" title="Toggle music">Music: Off</button>
        <button id="sfxBtn" title="Toggle sounds">SFX: On</button>
        <label style="display:inline-flex;align-items:center;gap:6px">Vol
          <input id="vol" type="range" min="0" max="1" step="0.01" value="0.35" />
        </label>
      </div>
    </header>

    <div class="hud">
      <div class="pill">Score: <span id="score">0</span></div>
      <div class="pill">Moves: <span id="moves">0</span></div>
      <div class="pill" id="stageInfo" style="display:none">Stage: <span id="stage">1</span> Â· Target: <span id="target">0</span> Â· Moves left: <span id="left">0</span></div>
      <button id="stageSelectBtn" class="btn secondary" style="display:none">Stage Select</button>
    </div>

    <div class="board-wrap card">
      <div id="grid" class="grid" aria-label="match-3 board"></div>
      <div id="toast" aria-live="polite"></div>
    </div>

    <div class="help">
      <strong>How to play</strong>: swap adjacent tiles. Calm = relaxed play with no restrictions; Challenge = stage-based play with target score & move limit. Chains resolve automatically. BGM off by default; SFX on.
    </div>
    <div class="footer">
      <div><strong>How to play</strong>: Calm â€” relaxed, make matches freely. Challenge â€” stage-based with score target & move limit.</div>
      <div>Note: Progress is saved in your browser. It may be lost on different devices/browsers, private mode, or clearing site data. Recommended: modern desktop/tablet browser (Chrome, Edge, Firefox, Safari).</div>
      <div style="margin-top:6px"><a href="#" target="_blank" rel="noopener" style="color:#111827; text-decoration:underline">ðŸŽµ murmur. YouTube Channel</a></div>
    </div>
  </div>
</div>

<!-- Overlay container -->
<div id="overlay" class="overlay">
  <div class="sheet" id="sheet"></div>
</div>

<script>
  // --- configuration
  const SIZE = 6;                // 6x6 board
  const KINDS = 6;               // kinds of tiles (we'll use 6 image themes)
  const LABELS = ["ramune","latte","tart","pudding","violet","macaron"]; // a11y labels
  const IMAGE_PATH = "images/";
  const PIECE_URLS = [
    IMAGE_PATH + "lemon_soda_tile.png",     // lemon jelly soda
    IMAGE_PATH + "cafelatte_tile.png",      // cafe latte
    IMAGE_PATH + "strawberry_tart_tile.png",// strawberry tart
    IMAGE_PATH + "caramelpudding_tile.png", // caramel pudding
    IMAGE_PATH + "violet_soda_tile.png",    // violet soda
    IMAGE_PATH + "vanilla_macaron_tile.png" // vanilla macaron
  ];
  const WELCOME_CAT_URL = IMAGE_PATH + "welcome_cat.png";

  // --- dom refs
  const gridEl  = document.getElementById('grid');
  const scoreEl = document.getElementById('score');
  const movesEl = document.getElementById('moves');
  const resetBtn= document.getElementById('resetBtn');
  const hintBtn = document.getElementById('hintBtn');
  const modeBtn = document.getElementById('modeBtn');
  const paceBtn = document.getElementById('paceBtn');
  const musicBtn= document.getElementById('musicBtn');
  const sfxBtn  = document.getElementById('sfxBtn');
  const volEl   = document.getElementById('vol');
  const overlay = document.getElementById('overlay');
  const sheet   = document.getElementById('sheet');
  const stageInfo = document.getElementById('stageInfo');
  const stageEl = document.getElementById('stage');
  const targetEl= document.getElementById('target');
  const leftEl  = document.getElementById('left');
  const stageSelectBtn = document.getElementById('stageSelectBtn');
  gridEl.style.setProperty('--size', SIZE);

  // --- state
  let board = [];
  let selected = null;
  let score = 0;
  let moves = 0;            // successful swaps
  let busy = false;
  let clusterMode = true;   // true=Calm; false=Challenge (both clear clusters)
  const Pace = { Fast:0, Normal:1, Slow:2 };
  let pace = Pace.Normal;
  const paceFactor = ()=> pace===Pace.Fast? 0.8 : pace===Pace.Normal? 1.0 : 1.8;
  let INTERNAL_MUTE = false;
  let userInteracted = false;

  // Challenge meta
  let currentStage = 1;
  let unlocked = parseInt(localStorage.getItem('mmq_unlocked')||'1',10);
  let movesLeft = 0;   // stage move budget
  let targetScore = 0; // stage target

  // --- audio
  let musicEnabled = false, sfxEnabled = true, audioPrimed = false;
  // BGM playlist (random, non-repeating)
  const BGM_LIST = [
    'bgm/match_game_bgm_1.mp3',
    'bgm/match_game_bgm_2.mp3',
    'bgm/match_game_bgm_3.mp3',
    'bgm/match_game_bgm_4.mp3',
    'bgm/match_game_bgm_5.mp3'
  ];
  let bgmIndex = Math.floor(Math.random()*BGM_LIST.length);
  const bgm = new Audio(); bgm.loop = false; bgm.preload = 'metadata';
  const sfxClear = new Audio('sounds/match.mp3'); sfxClear.volume = 0.25;
  const sfxSwap  = new Audio('sounds/choice.mp3');  sfxSwap.volume  = 0.15;

  function tryPlayAudio(a){
    if(!a) return;
    a.play().catch(e=>{ if(e?.name!=='NotAllowedError') console.warn('[audio]',e); });
  }
  function playNextBgm(){
    if(!musicEnabled) return; // safety
    bgm.src = BGM_LIST[bgmIndex];
    bgm.volume = parseFloat(volEl?.value || '0.35');
    tryPlayAudio(bgm);
    bgm.onended = ()=>{
      const prev = bgmIndex;
      do { bgmIndex = Math.floor(Math.random()*BGM_LIST.length); } while (bgmIndex===prev && BGM_LIST.length>1);
      playNextBgm();
    };
  }

  // Toast / combo image badge (disabled image for now)
  let toastTimer=null;
  function showCombo(totalCombo, groups=1){
    const toast=document.getElementById('toast'); if(!toast) return;
    const jump = groups>1 ? `<span class="jump">+${groups}</span>` : '';
    toast.innerHTML = `${totalCombo} combo! ${jump}`;
    toast.classList.remove('show'); void toast.offsetWidth; toast.classList.add('show');
    if(toastTimer) clearTimeout(toastTimer);
    const dur = 1000 + Math.min(600, (groups-1)*200);
    toastTimer = setTimeout(()=> toast.classList.remove('show'), dur);
  }

  // --- helpers
  function idx(r,c){ return r*SIZE + c; }
  function rc(i){ return [Math.floor(i/SIZE), i%SIZE]; }
  function randomKind(){ return (Math.random()*KINDS)|0; }
  function makeTile(kind){ return { kind, clearing:false }; }
  function neighbors(i){ const [r,c]=rc(i); const ns=[]; if(r>0)ns.push(idx(r-1,c)); if(r<SIZE-1)ns.push(idx(r+1,c)); if(c>0)ns.push(idx(r,c-1)); if(c<SIZE-1)ns.push(idx(r,c+1)); return ns; }

  // --- stage config (simple curve)
  function stageConfig(n){
    const baseTarget = 280; // gentle start
    const targetGrow = 24;  // per stage
    const baseMoves  = 18;  // start budget
    return {
      target: baseTarget + (n-1)*targetGrow,
      moves:  Math.max(10, baseMoves - Math.floor((n-1)/8)), // slowly harder
    };
  }

  // --- init & render
  function initBoard(){
    board = new Array(SIZE*SIZE).fill(0).map(()=> makeTile(randomKind()));
    score = 0; moves = 0; updateHUD();
    pruneInitialMatchesStrict();   // remove any initial line-3 or cluster-3
    ensurePossibleMove();
    render();
  }

  function updateHUD(){
    scoreEl.textContent = String(score);
    movesEl.textContent = String(moves);
    if(!clusterMode){
      stageInfo.style.display = '';
      stageEl.textContent = String(currentStage);
      targetEl.textContent= String(targetScore);
      leftEl.textContent  = String(movesLeft);
      stageSelectBtn.style.display='';
    }else{
      stageInfo.style.display = 'none';
      stageSelectBtn.style.display='none';
    }
  }

  function render(){
    gridEl.innerHTML = '';
    board.forEach((t,i)=>{
      const el=document.createElement('div');
      el.className=`tile ${t?.clearing? 'clearing':''}`;
      el.dataset.i=i; el.setAttribute('role','button'); el.setAttribute('aria-label', LABELS[t?.kind||0]||'tile');
      if(t){
        const img = document.createElement('img');
        img.src = PIECE_URLS[t.kind] || '';
        img.alt = LABELS[t.kind] || '';
        el.appendChild(img);
      }
      if(selected===i) el.classList.add('selected');
      el.addEventListener('click',()=> onTileClick(i));
      gridEl.appendChild(el);
    });
  }

  // --- core logic
  function swap(i,j, silent=false){ const tmp=board[i]; board[i]=board[j]; board[j]=tmp; if(!silent) playSwapSFX(); }

  function findMatches(){
    const matches = new Set();
    // rows
    for(let r=0;r<SIZE;r++){
      let runK=-1, runStart=0;
      for(let c=0;c<=SIZE;c++){
        const cell = (c<SIZE)? board[idx(r,c)] : null; const k = cell? cell.kind : -999;
        if(k!==runK){ if(c-runStart>=3 && runK!==-1){ for(let cc=runStart;cc<c;cc++) matches.add(idx(r,cc)); } runK=k; runStart=c; }
      }
    }
    // cols
    for(let c=0;c<SIZE;c++){
      let runK=-1, runStart=0;
      for(let r=0;r<=SIZE;r++){
        const cell = (r<SIZE)? board[idx(r,c)] : null; const k = cell? cell.kind : -999;
        if(k!==runK){ if(r-runStart>=3 && runK!==-1){ for(let rr=runStart;rr<r;rr++) matches.add(idx(rr,c)); } runK=k; runStart=r; }
      }
    }
    return [...matches];
  }

  function expandClusters(cells){
    if(!cells.length) return cells;
    const seen = new Set(cells); const q=[...cells];
    while(q.length){ const i=q.pop(); const k=board[i]?.kind; for(const j of neighbors(i)){ if(!seen.has(j) && board[j] && board[j].kind===k){ seen.add(j); q.push(j); } } }
    return [...seen];
  }

  function groupsIn(cells){
    if(!cells || !cells.length) return 0;
    const set=new Set(cells), seen=new Set(); let count=0;
    for(const i of set){ if(seen.has(i)) continue; count++; const k=board[i]?.kind; const st=[i]; seen.add(i); while(st.length){ const v=st.pop(); for(const w of neighbors(v)){ if(!seen.has(w) && set.has(w) && board[w] && board[w].kind===k){ seen.add(w); st.push(w); } } }
    }
    return count;
  }

  function safeRandomKind(r,c){
    let tries=0; while(tries++<12){ const k=randomKind(); const makesV=(r+2<=SIZE-1)&&board[idx(r+1,c)]&&board[idx(r+2,c)]&&board[idx(r+1,c)].kind===k&&board[idx(r+2,c)].kind===k; const makesH=(c-2>=0)&&board[idx(r,c-1)]&&board[idx(r,c-2)]&&board[idx(r,c-1)].kind===k&&board[idx(r,c-2)].kind===k; if(!makesV&&!makesH) return k; }
    return randomKind();
  }

  function clustersOfSizeAtLeast(min=3){
    const res=new Set(), seen=new Set();
    for(let i=0;i<board.length;i++){
      if(seen.has(i)||!board[i]) continue; const k=board[i].kind; const comp=[]; const st=[i]; seen.add(i);
      while(st.length){ const v=st.pop(); comp.push(v); for(const w of neighbors(v)){ if(!seen.has(w)&&board[w]&&board[w].kind===k){ seen.add(w); st.push(w); } }
      }
      if(comp.length>=min){ comp.forEach(x=>res.add(x)); }
    }
    return [...res];
  }

  // scoring (Calm gets mild bonus)
  function addScore(cells, groups, totalCombo){
    const base = cells * 10;
    if(clusterMode){ // Calm
      const chainBonus = base * Math.max(0, totalCombo-1) * 0.06; // +6% per combo tier beyond 1
      const simultaneous = Math.max(0, groups-1) * 5;            // +5 per extra simultaneous group
      return Math.round(base + chainBonus + simultaneous);
    }
    return base; // Challenge: flat
  }

  async function resolveAll(){
    let combo=0;
    while(true){
      // In both modes we clear clusters (L/T/blocks OK)
      let toClear = clustersOfSizeAtLeast(3);
      if(!toClear.length) break;
      const groups = groupsIn(toClear);
      combo += Math.max(1, groups); // simultaneous jump
      showCombo(combo, groups);
      toClear.forEach(i=> board[i].clearing=true);
      render(); await sleep(260*paceFactor());
      toClear.forEach(i=> board[i]=null);
      score += addScore(toClear.length, groups, combo); updateHUD();
      playClearSFX();
      // drop & refill
      for(let c=0;c<SIZE;c++){
        let write=SIZE-1; for(let r=SIZE-1;r>=0;r--){ const i=idx(r,c); if(board[i]!=null){ const j=idx(write,c); if(i!==j) board[j]=board[i]; write--; } }
        for(let r=write;r>=0;r--){ const kind=safeRandomKind(r,c); board[idx(r,c)] = makeTile(kind); }
      }
      board.forEach(t=> t && (t.clearing=false));
      render(); await sleep(160*paceFactor());
    }
  }

  function hasPossibleMove(){
    INTERNAL_MUTE=true;
    for(let i=0;i<board.length;i++){
      for(const j of neighbors(i)){
        swap(i,j,true);
        const ok = clustersOfSizeAtLeast(3).length>0;
        swap(i,j,true);
        if(ok){ INTERNAL_MUTE=false; return true; }
      }
    }
    INTERNAL_MUTE=false; return false;
  }

  function ensurePossibleMove(){
    INTERNAL_MUTE=true; let guard=0;
    while(!hasPossibleMove() && guard++<100){
      const a=(Math.random()*board.length)|0; const ns=neighbors(a); const b=ns[(Math.random()*ns.length)|0];
      swap(a,b,true);
      const offenders=new Set([...new Set(findMatches()), ...new Set(clustersOfSizeAtLeast(3))]);
      if(offenders.size){ for(const i of offenders){ const [r,c]=rc(i); board[i]=makeTile(safeRandomKind(r,c)); } }
    }
    INTERNAL_MUTE=false;
  }

  function pruneInitialMatchesStrict(){
    let guard=0; while(guard++<200){
      const line=new Set(findMatches());
      const cluster=new Set(clustersOfSizeAtLeast(3));
      const victims=new Set([...line,...cluster]);
      if(!victims.size) break;
      for(const i of victims){ const [r,c]=rc(i); board[i]=makeTile(safeRandomKind(r,c)); }
    }
  }

  async function onTileClick(i){
    userInteracted=true; if(busy) return; primeAudio();
    if(selected==null){ selected=i; render(); return; }
    if(i===selected){ selected=null; render(); return; }
    if(!neighbors(selected).includes(i)){ selected=i; render(); return; }
    swap(selected,i); render();
    const ok = clustersOfSizeAtLeast(3).length>0;
    if(ok){
      busy=true; moves++; if(!clusterMode){ movesLeft--; } updateHUD();
      await resolveAll();
      busy=false; selected=null; render();
      if(!hasPossibleMove()){ ensurePossibleMove(); render(); }
      if(!clusterMode){
        if(score>=targetScore){ onStageClear(); }
        else if(movesLeft<=0){ onStageFail(); }
      }
    }else{
      await sleep(120*paceFactor()); swap(selected,i); selected=null; render();
    }
  }

  function sleep(ms){ return new Promise(r=> setTimeout(r,ms)); }

  // --- overlay helpers
  function showOverlay(html){ sheet.innerHTML=html; overlay.classList.add('show'); }
  function hideOverlay(){ overlay.classList.remove('show'); sheet.innerHTML=''; }

  // Mode select on startup
  function showModeSelect(){
    showOverlay(`
      <button class="close-btn" id="closeOverlay">Ã—</button>
      <h2>Choose mode</h2>
      <div class="row" style="margin:6px 0 10px">
        <button class="btn" id="chooseCalm">Calm</button>
        <button class="btn secondary" id="chooseChallenge">Challenge</button>
      </div>
      <div class="meta" style="margin-top:10px">
        <div><strong>Calm</strong>: Relaxed mode with no restrictions â€” just make matches.</div>
        <div><strong>Challenge</strong>: Stage-based mode with target score & move limit.</div>
        <hr style="border:none;border-top:1px solid #e5e7eb; margin:10px 0">
        <div><strong>Note</strong>: Progress is saved in your browser (local storage). It may be lost if you use a different device/browser, private/incognito mode, or clear site data.</div>
        <div style="margin-top:6px"><strong>Recommended</strong>: Modern desktop or tablet browser (Chrome, Edge, Firefox, Safari).</div>
      </div>
      <img class="welcome-cat" src="${WELCOME_CAT_URL}" alt="welcome cat" />
    `);
    sheet.querySelector('#closeOverlay').onclick = ()=> hideOverlay();
    sheet.querySelector('#chooseCalm').onclick = ()=>{ hideOverlay(); switchToCalm(true); };
    sheet.querySelector('#chooseChallenge').onclick = ()=>{ hideOverlay(); openStageSelect(); };
  }

  // Stage select overlay
  function openStageSelect(){
    clusterMode=false; updateModeUI();
    const max=100; let grid='';
    for(let i=1;i<=max;i++){
      const lock = i>unlocked; const cleared = i<unlocked;
      grid += `<div class=\"stage ${lock?'lock':''} ${cleared?'clear':''}\" data-n=\"${i}\">${i}</div>`;
    }
    showOverlay(`
      <button class=\"close-btn\" id=\"closeOverlay\">Ã—</button>
      <h2>Challenge â€” Stage Select</h2>
      <div class=\"meta\" style=\"margin:4px 0 8px\">Choose a stage to play. Cleared stages are marked; locked stages will unlock as you progress.</div>
      <div class=\"stage-grid\">${grid}</div>
      <div class=\"row\" style=\"margin-top:10px; justify-content:center\">
        <button class=\"btn secondary\" id=\"backToCalm\">Back to Calm</button>
      </div>
    `);
    sheet.querySelector('#closeOverlay').onclick = ()=> hideOverlay();
    sheet.querySelectorAll('.stage').forEach(el=>{
      el.onclick = ()=>{ const n=parseInt(el.dataset.n,10); if(n>unlocked) return; hideOverlay(); startStage(n); };
    });
    sheet.querySelector('#backToCalm').onclick=()=>{ hideOverlay(); confirmSwitch(true); };
  }

  function startStage(n){
    currentStage=n; const cfg=stageConfig(n); targetScore=cfg.target; movesLeft=cfg.moves; initBoard(); updateHUD();
  }

  function onStageClear(){
    if(unlocked<currentStage+1){ unlocked=currentStage+1; localStorage.setItem('mmq_unlocked', String(unlocked)); }
    showOverlay(`
      <button class="close-btn" id="closeOverlay">Ã—</button>
      <h2>Stage ${currentStage} â€” Cleared ðŸŽ‰</h2>
      <p class="meta">Score ${score} / Target ${targetScore}</p>
      <div class="row">
        <button class="btn" id="nextStage">Next</button>
        <button class="btn secondary" id="select">Stage Select</button>
        <button class="btn secondary" id="retry">Retry</button>
      </div>
    `);
    sheet.querySelector('#closeOverlay').onclick = ()=> hideOverlay();
    sheet.querySelector('#nextStage').onclick = ()=>{ hideOverlay(); startStage(Math.min(100,currentStage+1)); };
    sheet.querySelector('#select').onclick    = ()=>{ openStageSelect(); };
    sheet.querySelector('#retry').onclick     = ()=>{ hideOverlay(); startStage(currentStage); };
  }

  function onStageFail(){
    showOverlay(`
      <button class="close-btn" id="closeOverlay">Ã—</button>
      <h2>Stage ${currentStage} â€” Try again</h2>
      <p class="meta">Score ${score} / Target ${targetScore}</p>
      <div class="row">
        <button class="btn" id="retry">Retry</button>
        <button class="btn secondary" id="select">Stage Select</button>
      </div>
    `);
    sheet.querySelector('#closeOverlay').onclick = ()=> hideOverlay();
    sheet.querySelector('#retry').onclick  = ()=>{ hideOverlay(); startStage(currentStage); };
    sheet.querySelector('#select').onclick = ()=>{ openStageSelect(); };
  }

  // switching calm/challenge with confirm & reset
  function updateModeUI(){ modeBtn.textContent = `Mode: ${clusterMode? 'Calm':'Challenge'}`; }
  function switchToCalm(fromSelect=false){ clusterMode=true; updateModeUI(); initBoard(); updateHUD(); if(!fromSelect) hideOverlay(); }
  function confirmSwitch(backToCalm=false){
    const to = backToCalm? 'Calm' : (clusterMode? 'Challenge':'Calm');
    showOverlay(`
      <button class="close-btn" id="closeOverlay">Ã—</button>
      <h2>Switch to ${to}?</h2>
      <p class="meta">Score will be reset. Continue?</p>
      <div class="row" style="justify-content:center">
        <button class="btn" id="yes">Switch</button>
        <button class="btn secondary" id="no">Cancel</button>
      </div>
    `);
    sheet.querySelector('#closeOverlay').onclick = ()=> hideOverlay();
    sheet.querySelector('#yes').onclick = ()=>{
      hideOverlay();
      score=0; moves=0; updateHUD();
      if(backToCalm || !clusterMode){ switchToCalm(); } else { openStageSelect(); }
    };
    sheet.querySelector('#no').onclick  = ()=> hideOverlay();
  }

  // --- audio UI & events
  function updateAudioUI(){
    musicBtn.textContent = `Music: ${musicEnabled? 'On':'Off'}`;
    sfxBtn.textContent   = `SFX: ${sfxEnabled? 'On':'Off'}`;
    paceBtn.textContent  = `Pace: ${pace===Pace.Fast? 'Fast' : pace===Pace.Normal? 'Normal':'Slow'}`;
    bgm.volume = parseFloat(volEl.value);
  }
  function primeAudio(){ if(audioPrimed) return; audioPrimed=true; if(musicEnabled && userInteracted){ playNextBgm(); } }
  function playSwapSFX(){ if(sfxEnabled && !INTERNAL_MUTE && userInteracted){ sfxSwap.currentTime=0; tryPlayAudio(sfxSwap); } }
  function playClearSFX(){ if(sfxEnabled && !INTERNAL_MUTE && userInteracted){ sfxClear.currentTime=0; tryPlayAudio(sfxClear); } }

  function findHint(){
    INTERNAL_MUTE=true;
    for(let i=0;i<board.length;i++){
      for(const j of neighbors(i)){
        swap(i,j,true);
        const ok = clustersOfSizeAtLeast(3).length>0;
        swap(i,j,true);
        if(ok){ INTERNAL_MUTE=false; return [i,j]; }
      }
    }
    INTERNAL_MUTE=false; return null;
  }

  resetBtn.addEventListener('click', ()=> initBoard());
  hintBtn .addEventListener('click', ()=>{ const h=findHint(); if(!h){ ensurePossibleMove(); render(); return; } const [a,b]=h; const els=[...gridEl.children]; [a,b].forEach(i=>{ const el=els[i]; if(!el) return; el.style.outline='3px solid rgba(31,41,55,.28)'; setTimeout(()=> el.style.outline='', 700); }); });
  modeBtn.addEventListener('click', ()=>{ confirmSwitch(); });
  paceBtn.addEventListener('click', ()=>{ pace = pace===Pace.Fast? Pace.Normal : pace===Pace.Normal? Pace.Slow : Pace.Fast; updateAudioUI(); });
  musicBtn.addEventListener('click', ()=>{
    musicEnabled=!musicEnabled; updateAudioUI();
    if(musicEnabled && userInteracted){ playNextBgm(); }
    else { bgm.pause(); }
  });
  sfxBtn .addEventListener('click', ()=>{ sfxEnabled=!sfxEnabled; updateAudioUI(); });
  volEl  .addEventListener('input', ()=> updateAudioUI());
  stageSelectBtn.addEventListener('click', ()=> openStageSelect());

  // --- minimal self tests
  (function selfTests(){
    try{
      setTimeout(()=>{
        const count = gridEl?.children?.length || 0; console.assert(count === SIZE*SIZE, `expected ${SIZE*SIZE} tiles, got ${count}`);
        console.assert(findMatches().length===0, 'no initial line-3');
        console.assert(clustersOfSizeAtLeast(3).length===0, 'no initial cluster-3');
      }, 250);
    }catch(e){ console.warn('[selftest]', e); }
  })();

  // --- start
  document.addEventListener('pointerdown', ()=>{ userInteracted = true; });
  function hardInit(){ try{ initBoard(); }catch(e){ console.error(e); }
    setTimeout(()=>{ showModeSelect(); }, 50);
    updateAudioUI();
  }
  document.addEventListener('DOMContentLoaded', hardInit);
</script>
</body>
</html>

